/**
 * Tests for Vulnerability Scanner Service
 */

import { createVulnerabilityScanner } from './vulnerability-scanner';
import type { SecurityDataSource, Package, Vulnerability } from '../../types';
import { VulnerabilitySeverity } from '../../types';

// Mock security data source for testing
class MockSecurityDataSource implements SecurityDataSource {
  name = 'mock-source';
  description = 'Mock security data source for testing';
  priority = 1;

  private vulnerabilities: Vulnerability[] = [];

  setVulnerabilities(vulns: Vulnerability[]): void {
    this.vulnerabilities = vulns;
  }

  async getVulnerabilities(pkg: Package): Promise<Vulnerability[]> {
    // Return vulnerabilities that match the package name
    return this.vulnerabilities.filter(v => 
      v.title.includes(pkg.name) || pkg.name === 'vulnerable-package'
    );
  }

  async isAvailable(): Promise<boolean> {
    return true;
  }
}

describe('VulnerabilityScanner', () => {
  let mockDataSource: MockSecurityDataSource;
  let scanner: ReturnType<typeof createVulnerabilityScanner>;

  beforeEach(() => {
    mockDataSource = new MockSecurityDataSource();
    scanner = createVulnerabilityScanner([mockDataSource]);
  });

  describe('scanPackage', () => {
    it('should scan a package with no vulnerabilities', async () => {
      const pkg: Package = {
        name: 'safe-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      mockDataSource.setVulnerabilities([]);

      const result = await scanner.scanPackage(pkg);

      expect(result.package).toBe(pkg);
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.riskScore).toBe(0);
      expect(result.riskLevel).toBe('low');
      expect(result.recommendations).toHaveLength(1);
      expect(result.recommendations[0]?.type).toBe('monitor');
    });

    it('should scan a package with vulnerabilities', async () => {
      const pkg: Package = {
        name: 'vulnerable-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      const testVulnerability: Vulnerability = {
        id: 'TEST-001',
        cveId: 'CVE-2023-0001',
        title: 'Test vulnerability in vulnerable-package',
        description: 'A test vulnerability for testing purposes',
        severity: VulnerabilitySeverity.HIGH,
        cvssScore: 7.5,
        publishedAt: new Date('2023-01-01'),
        updatedAt: new Date('2023-01-01'),
        affectedVersions: ['1.0.0'],
        patchedVersions: ['1.1.0'],
        references: [{ url: 'https://example.com/advisory', type: 'advisory' }],
        source: 'mock-source' as any
      };

      mockDataSource.setVulnerabilities([testVulnerability]);

      const result = await scanner.scanPackage(pkg);

      expect(result.vulnerabilities).toHaveLength(1);
      expect(result.vulnerabilities[0]?.severity).toBe(VulnerabilitySeverity.HIGH);
      expect(result.riskScore).toBeGreaterThan(0);
      expect(result.riskLevel).toBe('medium'); // HIGH severity (7 points) = medium risk level
      expect(result.recommendations.length).toBeGreaterThan(0);
    });

    it('should handle multiple vulnerabilities with different severities', async () => {
      const pkg: Package = {
        name: 'vulnerable-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      const vulnerabilities: Vulnerability[] = [
        {
          id: 'TEST-001',
          title: 'Critical vulnerability',
          description: 'A critical security issue',
          severity: VulnerabilitySeverity.CRITICAL,
          cvssScore: 9.8,
          publishedAt: new Date(),
          updatedAt: new Date(),
          affectedVersions: ['1.0.0'],
          patchedVersions: [],
          references: [],
          source: 'mock-source' as any
        },
        {
          id: 'TEST-002',
          title: 'Medium vulnerability',
          description: 'A medium security issue',
          severity: VulnerabilitySeverity.MEDIUM,
          cvssScore: 5.0,
          publishedAt: new Date(),
          updatedAt: new Date(),
          affectedVersions: ['1.0.0'],
          patchedVersions: ['1.1.0'],
          references: [],
          source: 'mock-source' as any
        }
      ];

      mockDataSource.setVulnerabilities(vulnerabilities);

      const result = await scanner.scanPackage(pkg);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.riskLevel).toBe('high'); // CRITICAL (10) + MEDIUM (4) = 14 points = high risk level
      expect(result.riskScore).toBeGreaterThan(10); // Critical + medium should be > 10
    });

    it('should generate appropriate recommendations', async () => {
      const pkg: Package = {
        name: 'vulnerable-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      const vulnerability: Vulnerability = {
        id: 'TEST-001',
        title: 'Patchable vulnerability',
        description: 'A vulnerability with available patches',
        severity: VulnerabilitySeverity.HIGH,
        publishedAt: new Date(),
        updatedAt: new Date(),
        affectedVersions: ['1.0.0'],
        patchedVersions: ['1.1.0', '1.2.0'],
        references: [],
        source: 'mock-source' as any
      };

      mockDataSource.setVulnerabilities([vulnerability]);

      const result = await scanner.scanPackage(pkg);

      const updateRecommendation = result.recommendations.find(r => r.type === 'update');
      expect(updateRecommendation).toBeTruthy();
      expect(updateRecommendation?.priority).toBe('high');
      expect(updateRecommendation?.action).toContain('1.2.0');
    });
  });

  describe('scanPackages', () => {
    it('should scan multiple packages', async () => {
      const packages: Package[] = [
        {
          name: 'safe-package-1',
          version: '1.0.0',
          dependencies: new Map()
        },
        {
          name: 'vulnerable-package',
          version: '1.0.0',
          dependencies: new Map()
        },
        {
          name: 'safe-package-2',
          version: '2.0.0',
          dependencies: new Map()
        }
      ];

      const vulnerability: Vulnerability = {
        id: 'TEST-001',
        title: 'Test vulnerability',
        description: 'A test vulnerability',
        severity: VulnerabilitySeverity.MEDIUM,
        publishedAt: new Date(),
        updatedAt: new Date(),
        affectedVersions: ['1.0.0'],
        patchedVersions: [],
        references: [],
        source: 'mock-source' as any
      };

      mockDataSource.setVulnerabilities([vulnerability]);

      const result = await scanner.scanPackages(packages);

      expect(result.reports).toHaveLength(3);
      expect(result.summary.totalPackages).toBe(3);
      expect(result.summary.scannedPackages).toBe(3);
      expect(result.summary.totalVulnerabilities).toBe(1);
      expect(result.summary.mediumVulnerabilities).toBe(1);
      expect(result.summary.packagesWithVulnerabilities).toBe(1);
    });

    it('should calculate summary statistics correctly', async () => {
      const packages: Package[] = [
        {
          name: 'vulnerable-package',
          version: '1.0.0',
          dependencies: new Map()
        }
      ];

      const vulnerabilities: Vulnerability[] = [
        {
          id: 'CRITICAL-001',
          title: 'Critical issue',
          description: 'Critical vulnerability',
          severity: VulnerabilitySeverity.CRITICAL,
          publishedAt: new Date(),
          updatedAt: new Date(),
          affectedVersions: ['1.0.0'],
          patchedVersions: [],
          references: [],
          source: 'mock-source' as any
        },
        {
          id: 'HIGH-001',
          title: 'High issue',
          description: 'High vulnerability',
          severity: VulnerabilitySeverity.HIGH,
          publishedAt: new Date(),
          updatedAt: new Date(),
          affectedVersions: ['1.0.0'],
          patchedVersions: [],
          references: [],
          source: 'mock-source' as any
        },
        {
          id: 'LOW-001',
          title: 'Low issue',
          description: 'Low vulnerability',
          severity: VulnerabilitySeverity.LOW,
          publishedAt: new Date(),
          updatedAt: new Date(),
          affectedVersions: ['1.0.0'],
          patchedVersions: [],
          references: [],
          source: 'mock-source' as any
        }
      ];

      mockDataSource.setVulnerabilities(vulnerabilities);

      const result = await scanner.scanPackages(packages);

      expect(result.summary.totalVulnerabilities).toBe(3);
      expect(result.summary.criticalVulnerabilities).toBe(1);
      expect(result.summary.highVulnerabilities).toBe(1);
      expect(result.summary.lowVulnerabilities).toBe(1);
      expect(result.summary.mediumVulnerabilities).toBe(0);
    });

    it('should respect maxConcurrentPackages option', async () => {
      // Data source that records concurrent calls
      let concurrent = 0;
      let peak = 0;
      const delays: number[] = [];
      const delayingSource: SecurityDataSource = {
        name: 'delaying-source',
        description: 'Introduces artificial delay',
        priority: 1,
        async getVulnerabilities(_pkg: Package): Promise<Vulnerability[]> {
          concurrent++;
          peak = Math.max(peak, concurrent);
          // Variable delay to increase overlap
          const delay = 30 + Math.random() * 20;
          delays.push(delay);
          await new Promise(r => setTimeout(r, delay));
          concurrent--;
          return [];
        },
        async isAvailable() { return true; }
      };

      const localScanner = createVulnerabilityScanner([delayingSource]);
      const pkgs: Package[] = Array.from({ length: 12 }, (_, i) => ({ name: `p${i}`, version: '1.0.0', dependencies: new Map() }));

      await localScanner.scanPackages(pkgs, { maxConcurrentPackages: 3 });

      expect(peak).toBeLessThanOrEqual(3);
      expect(peak).toBeGreaterThan(0);
    });
  });

  describe('vulnerability deduplication', () => {
    it('should deduplicate vulnerabilities with same CVE ID', async () => {
      const pkg: Package = {
        name: 'vulnerable-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      // Add a second data source with overlapping vulnerabilities
      const mockDataSource2 = new MockSecurityDataSource();
      mockDataSource2.name = 'mock-source-2';
      
      const scanner2 = createVulnerabilityScanner([mockDataSource, mockDataSource2]);

      const baseVuln = {
        id: 'TEST-001',
        cveId: 'CVE-2023-0001',
        title: 'Duplicate vulnerability',
        description: 'First version',
        severity: VulnerabilitySeverity.MEDIUM,
        publishedAt: new Date(),
        updatedAt: new Date(),
        affectedVersions: ['1.0.0'],
        patchedVersions: [],
        references: [],
        source: 'mock-source' as any
      };

      const duplicateVuln = {
        ...baseVuln,
        id: 'TEST-002',
        description: 'Second version (longer description for testing merge)',
        severity: VulnerabilitySeverity.HIGH, // Higher severity
        source: 'mock-source-2' as any
      };

      mockDataSource.setVulnerabilities([baseVuln]);
      mockDataSource2.setVulnerabilities([duplicateVuln]);

      const result = await scanner2.scanPackage(pkg);

      // Should have only one vulnerability after deduplication
      expect(result.vulnerabilities).toHaveLength(1);
      
      // Should take the higher severity
      expect(result.vulnerabilities[0]?.severity).toBe(VulnerabilitySeverity.HIGH);
      
      // Should take the longer description
      expect(result.vulnerabilities[0]?.description).toContain('longer description');
    });
  });

  describe('error handling', () => {
    it('should handle data source failures gracefully', async () => {
      // Create a failing data source
      const failingDataSource: SecurityDataSource = {
        name: 'failing-source',
        description: 'A data source that always fails',
        priority: 1,
        async getVulnerabilities(_pkg: Package): Promise<Vulnerability[]> {
          throw new Error('Data source failure');
        },
        async isAvailable(): Promise<boolean> {
          return false;
        }
      };

      const robustScanner = createVulnerabilityScanner([mockDataSource, failingDataSource]);

      const pkg: Package = {
        name: 'test-package',
        version: '1.0.0',
        dependencies: new Map()
      };

      mockDataSource.setVulnerabilities([]);

      // Should not throw and should return results from working data source
      const result = await robustScanner.scanPackage(pkg);
      
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.scanMetadata.dataSourcesUsed).toContain('mock-source');
      expect(result.scanMetadata.dataSourcesUsed).toContain('failing-source');
    });
  });
});
