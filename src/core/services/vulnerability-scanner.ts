/**
 * Vulnerability Scanner Service - Phase 2 Core Implementation
 * Multi-source vulnerability aggregation with intelligent risk assessment
 */

import { getLogger } from '../../utils/logger';
import type { 
  Package, 
  Vulnerability,
  VulnerabilityReport,
  VulnerabilitySource,
  SecurityDataSource,
  VulnerabilityScanOptions,
  VulnerabilityScanResult
} from '../../types';

const logger = getLogger('VulnerabilityScanner');

/**
 * Enterprise-grade vulnerability scanner with multi-source intelligence
 */
export class VulnerabilityScanner {
  private dataSources: SecurityDataSource[] = [];
  private readonly maxConcurrentScans = 10;
  private readonly scanTimeoutMs = 30000; // 30 seconds

  constructor(dataSources: SecurityDataSource[] = []) {
    this.dataSources = dataSources;
    logger.info(`üõ°Ô∏è  Vulnerability scanner initialized with ${dataSources.length} data sources`);
  }

  /**
   * Register a new security data source
   */
  registerDataSource(dataSource: SecurityDataSource): void {
    this.dataSources.push(dataSource);
    logger.info(`üìä Registered data source: ${dataSource.name}`);
  }

  /**
   * Scan a single package for vulnerabilities
   */
  async scanPackage(
    pkg: Package, 
    options: VulnerabilityScanOptions = {}
  ): Promise<VulnerabilityReport> {
    const startTime = Date.now();
    logger.info(`üîç Scanning package: ${pkg.name}@${pkg.version}`);

    try {
      // Scan package across all data sources
      const vulnerabilities = await this.scanAcrossDataSources(pkg, options);
      
      // Deduplicate and merge vulnerabilities
      const mergedVulnerabilities = await this.mergeVulnerabilities(vulnerabilities);
      
      // Calculate risk assessment
      const riskAssessment = await this.assessRisk(pkg, mergedVulnerabilities, options);
      
      // Generate recommendations
      const recommendations = await this.generateRecommendations(pkg, mergedVulnerabilities);

      const scanTime = Date.now() - startTime;
      logger.info(`‚úÖ Package scan completed in ${scanTime}ms - Found ${mergedVulnerabilities.length} vulnerabilities`);

      return {
        package: pkg,
        vulnerabilities: mergedVulnerabilities,
        riskScore: riskAssessment.overallScore,
        riskLevel: riskAssessment.level,
        riskFactors: riskAssessment.factors,
        recommendations,
        scanMetadata: {
          scanTime: new Date(),
          scanDurationMs: scanTime,
          dataSourcesUsed: this.dataSources.map(ds => ds.name),
          scanOptions: options
        }
      };
    } catch (error) {
      logger.error(`Vulnerability scan failed for ${pkg.name}@${pkg.version}:`, error);
      throw new Error(`Vulnerability scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Scan multiple packages with intelligent batching
   */
  async scanPackages(
    packages: Package[], 
    options: VulnerabilityScanOptions = {}
  ): Promise<VulnerabilityScanResult> {
    const startTime = Date.now();
    logger.info(`üîç Starting vulnerability scan for ${packages.length} packages`);

    try {
      // Process packages in batches to prevent overwhelming data sources
      const batches = this.createBatches(packages, this.maxConcurrentScans);
      const allReports: VulnerabilityReport[] = [];
      
      for (const batch of batches) {
        const batchPromises = batch.map(pkg => this.scanPackage(pkg, options));
        const batchReports = await Promise.allSettled(batchPromises);
        
        // Process results and handle failures
        for (const result of batchReports) {
          if (result.status === 'fulfilled') {
            allReports.push(result.value);
          } else {
            logger.warn('Package scan failed:', result.reason);
          }
        }
      }

      // Aggregate results
      const totalVulnerabilities = allReports.reduce((sum, report) => sum + report.vulnerabilities.length, 0);
      const criticalVulns = allReports.reduce((sum, report) => 
        sum + report.vulnerabilities.filter((v: Vulnerability) => v.severity === 'critical').length, 0
      );
      const highVulns = allReports.reduce((sum, report) => 
        sum + report.vulnerabilities.filter((v: Vulnerability) => v.severity === 'high').length, 0
      );

      const scanTime = Date.now() - startTime;
      logger.info(`‚úÖ Vulnerability scan completed in ${scanTime}ms - Found ${totalVulnerabilities} vulnerabilities across ${allReports.length} packages`);

      return {
        reports: allReports,
        summary: {
          totalPackages: packages.length,
          scannedPackages: allReports.length,
          totalVulnerabilities,
          criticalVulnerabilities: criticalVulns,
          highVulnerabilities: highVulns,
          mediumVulnerabilities: allReports.reduce((sum, report) => 
            sum + report.vulnerabilities.filter((v: Vulnerability) => v.severity === 'medium').length, 0
          ),
          lowVulnerabilities: allReports.reduce((sum, report) => 
            sum + report.vulnerabilities.filter((v: Vulnerability) => v.severity === 'low').length, 0
          ),
          packagesWithVulnerabilities: allReports.filter(r => r.vulnerabilities.length > 0).length,
          averageRiskScore: allReports.length > 0 ? 
            allReports.reduce((sum, r) => sum + r.riskScore, 0) / allReports.length : 0
        },
        scanMetadata: {
          scanTime: new Date(),
          scanDurationMs: scanTime,
          dataSourcesUsed: this.dataSources.map(ds => ds.name),
          scanOptions: options
        }
      };
    } catch (error) {
      logger.error('Bulk vulnerability scan failed:', error);
      throw new Error(`Bulk vulnerability scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Scan package across all configured data sources
   */
  private async scanAcrossDataSources(
    pkg: Package, 
    _options: VulnerabilityScanOptions
  ): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    if (this.dataSources.length === 0) {
      logger.warn('No security data sources configured - returning empty results');
      return vulnerabilities;
    }

    // Scan across all data sources concurrently
    const scanPromises = this.dataSources.map(async dataSource => {
      try {
        logger.debug(`Scanning ${pkg.name}@${pkg.version} using ${dataSource.name}`);
        const sourceVulns = await Promise.race([
          dataSource.getVulnerabilities(pkg),
          this.createTimeoutPromise(this.scanTimeoutMs)
        ]);
        
        return sourceVulns.map((vuln: Vulnerability) => ({
          ...vuln,
          source: dataSource.name as VulnerabilitySource
        }));
      } catch (error) {
        logger.warn(`Data source ${dataSource.name} failed for ${pkg.name}:`, error);
        return [];
      }
    });

    const results = await Promise.allSettled(scanPromises);
    
    for (const result of results) {
      if (result.status === 'fulfilled') {
        vulnerabilities.push(...result.value);
      }
    }

    logger.debug(`Found ${vulnerabilities.length} vulnerabilities from ${this.dataSources.length} sources`);
    return vulnerabilities;
  }

  /**
   * Merge and deduplicate vulnerabilities from multiple sources
   */
  private async mergeVulnerabilities(vulnerabilities: Vulnerability[]): Promise<Vulnerability[]> {
    const vulnMap = new Map<string, Vulnerability>();
    
    for (const vuln of vulnerabilities) {
      const key = this.generateVulnerabilityKey(vuln);
      const existing = vulnMap.get(key);
      
      if (existing) {
        // Merge vulnerability data from multiple sources
        const merged = await this.mergeVulnerabilityData(existing, vuln);
        vulnMap.set(key, merged);
      } else {
        vulnMap.set(key, vuln);
      }
    }

    return Array.from(vulnMap.values()).sort((a, b) => {
      // Sort by severity (critical -> high -> medium -> low)
      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
  }

  /**
   * Generate a unique key for vulnerability deduplication
   */
  private generateVulnerabilityKey(vuln: Vulnerability): string {
    // Use CVE ID if available, otherwise use title + affected versions
    if (vuln.cveId) {
      return vuln.cveId;
    }
    
    return `${vuln.title}|${vuln.affectedVersions?.join(',') || 'all'}`;
  }

  /**
   * Merge vulnerability data from multiple sources
   */
  private async mergeVulnerabilityData(existing: Vulnerability, incoming: Vulnerability): Promise<Vulnerability> {
    // Take the highest severity
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    const severity = severityOrder[incoming.severity] > severityOrder[existing.severity] 
      ? incoming.severity 
      : existing.severity;

    // Merge references and sources
    const references = [...(existing.references || []), ...(incoming.references || [])]
      .filter((ref, index, arr) => arr.findIndex(r => r.url === ref.url) === index);

    return {
      ...existing,
      severity,
      references,
      // Keep the most detailed description
      description: incoming.description?.length > existing.description?.length 
        ? incoming.description 
        : existing.description,
      // Merge CVSS scores - take the higher one
      cvssScore: Math.max(existing.cvssScore || 0, incoming.cvssScore || 0),
      // Combine affected versions
      affectedVersions: [
        ...(existing.affectedVersions || []),
        ...(incoming.affectedVersions || [])
      ].filter((version, index, arr) => arr.indexOf(version) === index),
      // Keep the earliest published date
      publishedAt: existing.publishedAt && incoming.publishedAt 
        ? new Date(Math.min(existing.publishedAt.getTime(), incoming.publishedAt.getTime()))
        : existing.publishedAt || incoming.publishedAt,
      // Merge patch information
      ...(existing.patched !== undefined && { patched: existing.patched }),
      ...(incoming.patched !== undefined && !existing.patched && { patched: incoming.patched }),
      patchedVersions: [
        ...(existing.patchedVersions || []),
        ...(incoming.patchedVersions || [])
      ].filter((version, index, arr) => arr.indexOf(version) === index)
    };
  }

  /**
   * Assess risk for a package based on vulnerabilities and context
   */
  private async assessRisk(
    pkg: Package, 
    vulnerabilities: Vulnerability[],
    options: VulnerabilityScanOptions
  ): Promise<{
    overallScore: number;
    level: 'low' | 'medium' | 'high' | 'critical';
    factors: Array<{ factor: string; impact: number; description: string }>;
  }> {
    const factors: Array<{ factor: string; impact: number; description: string }> = [];
    let score = 0;

    // Base score from vulnerabilities
    for (const vuln of vulnerabilities) {
      const severityScore = { critical: 10, high: 7, medium: 4, low: 1 }[vuln.severity];
      score += severityScore;
      
      factors.push({
        factor: `${vuln.severity.toUpperCase()} vulnerability`,
        impact: severityScore,
        description: `${vuln.title} (${vuln.cveId || 'No CVE'})`
      });
    }

    // Context-based risk factors
    if (pkg.downloadCount && pkg.downloadCount > 1000000) {
      const popularityBonus = 2;
      score += popularityBonus;
      factors.push({
        factor: 'High popularity',
        impact: popularityBonus,
        description: 'Popular packages are higher priority targets'
      });
    }

    // Development vs production dependencies
    if (options.includeDevDependencies === false) {
      // Production dependencies are higher risk
      const prodRisk = 1.5;
      score *= prodRisk;
      factors.push({
        factor: 'Production dependency',
        impact: score * (prodRisk - 1),
        description: 'Production dependencies pose higher risk'
      });
    }

    // Determine risk level
    let level: 'low' | 'medium' | 'high' | 'critical';
    if (score >= 15) level = 'critical';
    else if (score >= 10) level = 'high';
    else if (score >= 5) level = 'medium';
    else level = 'low';

    return { overallScore: Math.round(score * 10) / 10, level, factors };
  }

  /**
   * Generate actionable recommendations based on vulnerabilities
   */
  private async generateRecommendations(
    pkg: Package, 
    vulnerabilities: Vulnerability[]
  ): Promise<Array<{
    type: 'update' | 'replace' | 'remove' | 'monitor';
    priority: 'high' | 'medium' | 'low';
    description: string;
    action: string;
  }>> {
    const recommendations: Array<{
      type: 'update' | 'replace' | 'remove' | 'monitor';
      priority: 'high' | 'medium' | 'low';
      description: string;
      action: string;
    }> = [];

    if (vulnerabilities.length === 0) {
      recommendations.push({
        type: 'monitor',
        priority: 'low',
        description: 'No vulnerabilities found',
        action: 'Continue monitoring for new vulnerabilities'
      });
      return recommendations;
    }

    // Check for patched versions
    const patchableVulns = vulnerabilities.filter(v => v.patchedVersions && v.patchedVersions.length > 0);
    if (patchableVulns.length > 0) {
      const latestPatch = patchableVulns
        .flatMap(v => v.patchedVersions || [])
        .sort()
        .pop();
        
      recommendations.push({
        type: 'update',
        priority: 'high',
        description: `${patchableVulns.length} vulnerabilities can be fixed by updating`,
        action: `Update ${pkg.name} to version ${latestPatch} or later`
      });
    }

    // Check for critical vulnerabilities without patches
    const criticalUnpatched = vulnerabilities.filter(
      v => v.severity === 'critical' && (!v.patchedVersions || v.patchedVersions.length === 0)
    );
    
    if (criticalUnpatched.length > 0) {
      recommendations.push({
        type: 'replace',
        priority: 'high',
        description: `${criticalUnpatched.length} critical vulnerabilities have no patches available`,
        action: `Consider replacing ${pkg.name} with an alternative package`
      });
    }

    return recommendations;
  }

  /**
   * Create batches for concurrent processing
   */
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Create a timeout promise for data source requests
   */
  private createTimeoutPromise(timeoutMs: number): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Data source request timeout')), timeoutMs);
    });
  }
}

/**
 * Factory function for creating vulnerability scanner
 */
export function createVulnerabilityScanner(dataSources: SecurityDataSource[] = []): VulnerabilityScanner {
  return new VulnerabilityScanner(dataSources);
}
